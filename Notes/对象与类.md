# 对象与类

## 1.0	类、封装与继承简概

​	**类**(class)是构造**对象**的模板或蓝图。是**对象**共同特征的描述(设计图)。

​	**对象**是真实存在的具体东西,或者说,**实例**。

​	我们可以将**类**想象成制作小甜饼的切割机，将**对象**想象为小甜饼。由**类**构造(construct)**对象**的过程称为**创建类的实例**(instance)。用 Java 编写的所有代码都位于某个类的内部。

​	**封装**（encapsulation , 有时称为数据隐藏） 是与**对象**有关的一个重要概念。从形式上看，**封装**不过是将数据和行为组合在一个包中， 并对**对象**的使用者隐藏了数据的实现方式。**对象**中的数据称为**实例域**（instance field), 操纵数据的过程称为**方法**（method) 。

​	对于每个特定的**类实例（对象）**都有一组特定的**实例域值**。这些值的集合就是这个对象的**当前状态**（state)。无论何时，只要向**对象**发送一个消息，它的**状态**就有可能发生改变。实现封装的关键在于<u>绝对不能让类中的方法直接地访问其他类的实例域</u>。程序仅通过对象的**方法**与对象数据进行交互。封装给对象赋予了**“ 黑盒”** 特征， 这是提高重用性和可靠性的关键。 这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据, 其他**对象**就不会知道或介意所发生的变化。

​	事实上， 在 Java 中, 所有的类都源自于一个“ 神通广大的超类”, 它就是Object。在扩展一个已有的类时， 这个扩展后的新类具有所扩展的类的全部属性和方法。在新类中，只需提供适用于这个新类的新方法和数据域就可以了。通过扩展一个类来建立另外一个类的过程称为**继承**（inheritance)。

## 1.1	对象简概

​	要想使用 OOP(面向对象程序设计),—定要清楚对象的三个主要特性：

​		•对象的行为（behavior) —— 可以对对象施加哪些操作，或可以对对象施加哪些方法？

​		•对象的状态（state) —— 当施加那些方法时，对象如何响应？

​		•对象标识（identity) —— 如何辨别具有相同行为与状态的不同对象？

​	同一个**类**的所有**对象实例**， 由于支持相同的行为而具有家族式的相似性。**对象**的行为是用**可调用的方法**定义的。

​	此外，每个**对象**都保存着描述当前特征的信息。这就是**对象的状态**。**对象的状态**可能会随着时间而发生改变，但这种改变<u>不会是自发</u>的。**对象状态**的改变必须通过调用**方法**实现(如果不经过**方法**调用就可以改变**对象状态**，只能说明**封装性**遭到了破坏。)

​	但是，**对象的状态**并不能完全描述一个**对象**。每个对象都有一个唯一的**身份(identity)**。同时, **对象**的这些关键特性在彼此之间相互影响着。



## 1.2	类之间的关系简概

​	在类之间， 最常见的关系有

​		•依赖（“ **uses**-**a**”）

​		•聚合（“ **has**-**a**”）

​		•继承（“ **is**-**a**”）

​	依赖（ **dependence** ), 即“ **uses**-**a**” 关系， 是一种最明显的、 最常见的关系。例如在订单处理系统中，**Order**类使用 **Account** 类是因为 **Order** 对象需要访问 **Account** 对象查看信用状态。但是 **Item** 类不依赖于 **Account** 类， 这是因为 **Item** 对象与客户账户无关。因此， 如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。

​	应该尽可能地将相互依赖的类减至最少。如果类 **A** 不知道 **B** 的存在， 它就不会关心 **B**的任何改变（这意味着 **B** 的改变不会导致 **A** 产生任何 **bug** )。用软件工程的术语来说，就是让类之间的耦合度最小。

​	聚合（**aggregation** ), 即“ **has**-**a** ” 关系， 是一种具体且易于理解的关系。例如， 一个**Order** 对象包含一些 **Item** 对象。聚合关系意味着类 **A** 的对象包含类 **B** 的对象。

​	继承（ **inheritance** ), 即“ **is**-**a**” 关系， 是一种用于表示特殊与一般关系的。例如，**RushOrder**类由 **Order** 类继承而来。在具有特殊性的**RushOrder**类中包含了一些用于优先处理的特殊方法， 以及一个计算运费的不同方法。而其他的方法， 如添加商品、 生成账单等都是从**Order**类继承来的。一般而言， 如果类 **A** 扩展类 **B**, 类 **A** 不但包含从类 **B** 继承的方法，还会拥有一些额外的功能。

### 1.25	类的种类

​	用来描述一类事物的类，专业叫做: Javabean类。在Javabean类中，是不写main方法的。

​	在以前，编写main方法的类，叫做测试类。可以在测试类中创建Javabean类的对象并进行赋值调用。

## 1.3	使用预定义类

### 1.31	对象与对象变量

​	<u>要想使用**对象**，就必须首先**构造对象**， 并指定其**初始状态**。然后，对**对象**应用方法。</u>

​	在Java中, 使用**构造器(constructor)**构造**新实例**。构造器是一种特殊的**方法**, 用来构造并初始化**对象**。下面以标准Java库中包含的一个Date类为例介绍对象的各个方面:

​		构造器的名字应该与类名相同。因此 Date 类的构造器名为 Date。要想构造一个 Date 对象， 需要在构造器前面加上 new 操作符，如下所示：

```java
new Date()//需要先import java.util.Date;
```

​		这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间。如果需要的话， 也可以将这个对象传递给一个方法：

```java
System.out.println(new Date());
```

​		或者， 也可以将一个方法应用于刚刚创建的对象。Date 类中有一个 toString 方法。这个方法将返回日期的字符串描述。下面的语句可以说明如何将 toString 方法应用于新构造的Date 对象上。

```java
String s = new Date().toString();
```

​		在这两个例子中， 构造的对象仅使用了一次。通常， 希望构造的对象可以多次使用， 因此，需要将**对象**存放在一个**变量**中：

```java
Date birthday = new Date();
```

​		在对象与对象变量之间存在着一个重要的区别。例如， 语句

```java
Date deadline; // deadline doesn't refer to any object
s = deadline.toStringO; // 编译错误
```

​		<u>定义了一个**对象变量** deadline, 它可以引用 Date 类型的对象</u>。但是，一定要认识到： 变量deadline 不是一个对象， 实际上也没有引用对象。此时，不能将任何 Date 方法应用于这个变量上。

​		必须首先初始化变量 deadline, 这里有两个选择。可以用新构造的对象初始化这个变量：

```java
deadline = new Date();
```

​		也可以让这个变量引用一个已存在的对象：

```java
deadline = birthday;
```

​		在 Java 中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new 操作符的返回值也是一个引用。下列语句：

```java
Date deadline = new Date();
```

​		有两个部分。表达式 new Date() 构造了一个 Date 类型的对象， 并且它的值是对新创建对象的

引用。这个引用存储在变量 deadline 中。

可以显式地将对象变量设置为 null, 表明这个对象变量目前没有引用任何对象。

```java
deadline = null;

if (deadline != null)

	System.out.println(deadline);
```

​		如果将一个方法应用于一个值为 null 的对象上，那么就会产生运行时错误。

```java
birthday = null;

String s = birthday.toString(); // runtime error!
```

​		局部变量不会自动地初始化为 null，而必须通过调用 new 或将它们设置为 null 进行初始化。

​		一定要认识到： <u>一个**对象变量**并没有实际包含一个**对象**，而仅仅只是引用一个**对象**。可以将Java对象变量理解成C++中的"对象指针"</u>。

### 1.32	LocalDate类

​	标准 Java 类库分别包含了两个类：

​		一个是用来表示时间点的 Date 类；另一个是用来表示大家熟悉的日历表示法的 LocalDate 类。

### 1.33	更改器方法与访问器方法

​	只访问对象而不修改对象的方法有时称为访问器方法(类似C/C++中的带const的函数), 不修改的有时称为更改器方法。

​	只返回实例域值的访问器又称为域访问器。

## 1.4	用户自定义类

### 1.41	以Employee类为例

```java
class Employee{//这是Employee类的定义
	private String name;//以下三个为Employee类的实例域, 用来存放将要操作的数据
	private double salary;//关键字private确保只有Employee类自身的方法能够访问这些实例域
	private LocalDate hireDay;
	public Employee (String n , double s, int year, int month , int day){//Employee类的构造器
		name = n;
		salary = s;
		hireDay = Local Date,of(year, month, day);
	}
	//以下是方法
	public String getName(){//关键字public意味着任何类的任何方法都可以调用这些方法
		return name;
	}
	public double getSalary(){
		return salary;
	}
	public Local Date getHi reDayO{
		return hireDay;
	}
	public void raiseSalary(double byPercent){
		double raise = salary * byPercent / 100;
		salary += raise;
	}
}
```

​	知识点见上代码中的注释。

### 1.43	构造器简概

​	•构造器与类同名

​	•每个类可以有一个以上的构造器

​	•构造器可以有 0 个、1 个或多个参数

​	•构造器没有返回值

​	•构造器**总是**伴随着 new 操作一起调用

```java
//例如:
public Employee(String n, double s, int year, int month, int day)
{
name = n;
salary = s;
LocalDate hireDay = LocalDate.of(year, month, day);
}
Employee A1 = new Eraployee("]ames Bond", 100000, 1950, 1, 1);//使用构造器
```

### 1.44	隐式参数和显式参数

```java
public void raiseSalary(double byPercent)
{
	double raise = salary * byPercent / 100;
	salary += raise;
}
//......
{
	Employee number007 = new Employee("Carl Cracker", 75000, 1987, 12 , 15);
	number007.raiseSalary(5);
    //......
}
```

​	raiseSalary 方法有两个参数。 第一个参数称为**隐式(implicit)参数**， 是<u>出现在方法名前的Employee类对象</u>。第二个参数位于方法名后面括号中的数值，这是一个**显式(explicit) 参数** 。（ 有些人把隐式参数称为方法调用的目标或接收者。)

​	**显式参数**是明显地列在方法声明中的， 例如 double byPercent。需要注意参数会把相同名字的实例域**屏蔽**起来，此时可以用this.salary访问实例域。

​	**隐式参数**没有出现在方法声明中。在每一个方法中， 关键字 **this** 表示**隐式参数**。 如果需要的话，可以用下列方式编写raiseSalary 方法：

```java
public void raiseSalary(double byPercent)
{
	double raise = this.salary * byPercent / 100;
	this.salary += raise;
}
```

### 1.45	封装相关

​	面向对象三大特征:封装、继承、多态

​	① 比起提供一个简单的公有数据域, 为了实现封装并在需要的时候获得或设置实例域的值, 正确的做法时提供:

​		•一个私有的数据域；

​		•一个公有的域访问器方法；

​		•一个公有的域更改器方法。

​	② **不要**编写(也要小心Java自带的) 返回 <u>可变对象的引用</u> 的访问器方法。可能会导致此可变对象的"父对象"的私有状态被绕过(改变)。如果需要返回一个可变对象的引用， 应该首先对它进行克隆（**clone** )。对象 **clone** 是

指存放在另一个位置上的对象副本。

```java
class Employee
{
	private Date hireDay ;
	public Date getHireDayO
	{
		return hireDay; // ×	不要这样子做
    }
    //...
}
```

```java
class Employee
{
	public Date getHireDayO
	{
		return (Date) hireDay.cloneO; // √	这样OK
	}
    //...
}
```

​	☆③ 封装原则告诉我们如何正确设计对象的属性和方法：

​		**<u>对象代表什么，就得封装对应的数据，并提供数据对应的行为。</u>**

​	例子:

​		1、人画圆，用面向对象思想编程，应该设计两个类: 人 和 圆

​		其中圆应该封装半径等数据，并且提供数据对应的行为——画。画应该是圆类的方法，而不是人类，因为画是利用圆的数据的行为。

​		2、人关门，用面向对象思想编程，应该设计两个类: 人 和 门

​		门在被关的过程中，所有的行为都与人无关。人只是去推(调用)了这个门(的方法)。所以门关的方法也应该封装在门类中。

### 1.46	类的访问权限

​	一个方法可以访问其所属类的所有对象的**私有**数据。

#### 1.461	final实例域

​	可以将实例域定义为final, 这会使构建对象时必须初始化此实例域。也就是说, 必须确保在每一个构造器执行之后，这个域的值被设置，并在后面的操作中其无法修改。final修饰符大都应用于基本 (primitive) 类型域，或不可变(immutable)类的域。<u>对可变的类使用修饰符会有一些不同的情况 ( 还不懂 )</u>





### 1.47	静态域与静态方法

#### 1.471	静态域

​	如果将域定义为static，每个类中就只有一个这样的域。但实例域是这个类的每一个对象都有一份(拷贝)的。静态域属于类，不属于任何独立的对象。以Employee类为例:

​		如果有 1000 个Employee类的对象， 则有 1000 个实例域id。但是， 只有一个静态域nextID。即使没有一个雇员对象， 静态域nextlD也存在。

#### 1.472	静态常量

​	例如Math类中的:

```java
public class Hath
{
    //...
	public static final double PI = 3.14159265358979323846;
	//...
}
```

​	在程序中，可以采用 Math.PI 的形式获得这个常量。

​	如果关键字 static 被省略， PI 就变成了 Math 类的一个实例域: 需要通过 Math 类的对象访问 PI，并且每一个 Math 对象都有它自己的一份 PI 拷贝。

#### 1.473	静态方法

​	例如Math类的pow方法:

```java
Math.pow(x,a)
```

​	静态方法是一种不能向对象实施操作的方法，换句话说，没有隐式的参数(即无this参数)。其不能访问实例域，因为它不能操作对象。但是，<u>静态方法可以访问自身类中的静态域</u>。

​	可以在下面两种情况下使用静态方法：

​		•一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow) 。

​		•一个方法只需要访问类的静态域（例如：Employee.getNextld)。

#### 1.474	静态工厂方法

​	例如 NumberFormat 类如下使用工厂方法生成不同风格的格式化对象：

```java
NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();
NumberFormat percentFormatter = NumberFormat.getPercentInstance();
double x = 0.1;
System.out.println(currencyFormatter.format(x)); // print $0.10
System.out.println(percentFomatter.format(x)); // print 10%
```

#### 1.475	main方法

​	main方法也是一个静态方法。

### 1.48	transient关键字(翻源码时看到的)

​	transient(*/trænʃ(ə)nt/*)是Java中的一个关键字，它用于标记一个成员变量不需要被序列化，也就是说，在对象被转换为字节流的时候，这个变量的值会被忽略这个关键字.在Java中有一些安全性和效率方面的作用。例如，如果一个程序需要接收用户的登录名和密码，但我们不想把原始密码存储在文件中，我们可以用transient关键字来修饰密码变量。

### 1.49	一些类的命名原则

​	① 类名首字母建议大写，需要见名知意，驼峰模式。

​	② 一个Java文件中可以定义多个class类，且只能一个类是public修饰,而且public修饰的类名必须成为代码文件名。但在实际开发中还是一个文件定义一个class类。



## 1.5	方法(函数)的参数

​	C/C++中将参数传给方法(函数)的途径有两种,一是按值调用（call by value) (C/C++: 除指针以外的参数),二是按引用调用(call by reference)(C/C++: 指针)。

​	<u>Java总是采用按值调用</u>。也就是说， 方法得到的是所有参数值的一个拷贝，即方法不能修改传递给它的任何参数变量的内容。

​	<u>若想修改, 需要把对象的引用作为参数传入方法。</u>对象引用传入后也会被拷贝一次, 但它们引用的对象是同一个, 可以通过操作对象引用的拷贝达到修改对象的目的。但对对象引用的拷贝的操作往往是达不到原本目标或无意义的<u>(类似C/C++的函数中对作为形参的指针进行操作——不会影响实参)</u>。



## 1.6	对象构造的若干机制

### 1.61	重载

​	有些类可以有多个构造器, 以StringBuilder类为例:

```java
StringBuilder messages = new StringBuilder();//构造一个空的StringBuilder对象
StringBuilder todoList = new StringBuilder("To do:\n");//指定一个初始字符串
```

​	这种特征叫做**重载（ overloading)** 。如果多个方法（比如， StringBuilder 构造器方法）有**相同的名字、 不同的参数**，便产生了**重载**。

​	在调用方法的时候，如果方法出现了重载现象，则会优先调用实参和形参类型一致的那个方法。

​	编译器通过对比各个方法定义时的参数类型(显式参数)和具体使用时给予的参数类型(显式参数)来挑选出相应的方法。。如果编译器找不到匹配的参数， 就会产生编译时错误，因为根本不存在匹配， 或者没有一个比其他的更好。（这个过程被称为**重载解析（overloading resolution)**)

​	*注:由于重载的存在，若要完整地描述一个方法，需要指出方法名以及参数类型。这就是方法的签名(signature)。但要注意返回类型并不是方法签名[^1]的一部分,不能有两个名字相同、 参数类型也相同却返回不同类型值的方法。*

### 1.62	类域的默认初始化

​	如果在构造器中没有为域赋予初值，那么它就会被自动地附为默认值，这不是个好习惯。且需要注意局部变量并不会自动初始化。

### 1.63	在一个构造器中调用另一个构造器

​	如果构造器的第一个语句形如 this(...)， 这个构造器将调用同一个类的另一个构造器。下面是一个典型的例子：

```java
public Employee(double s)
{
// calls Employee(String, double)
	this("Employee #" + nextId, s);
	nextId++;
}
```

​	当调用 new Employee(60000) 时， Employee(double) 构造器将调用 Employee(String，double)构造器。这样对公共的构造器代码部分只编写一次即可。

### 1.64	初始化块

​	在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。

```java
class Employee
{
	private static int nextId;
	private int id;
	private String name;
	private double salary;
// object initialization block
	{
		id = nextId;
		nextId++;
	}//这就是代码块
    //...构造器
}
```

​	无论使用哪个构造器构造对象，id 域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器的主体部分。还有静态的初始化块，在块前加static 。





## 2.0	包

​	Java 允许使用包(package)将类组织起来。借助于包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。

​	标准的 Java 类库分布在多个包中，包括 java.lang、java.util 和java.net 等。标准的 Java包具有一个层次结构。如同硬盘的目录嵌套一样，也可以使用嵌套层次组织包。所有标准的Java 包都处于java 和 javax 包层次中。

​	使用包的主要原因是确保类名的唯一性。只要将这些类放置在不同的包中， 就不会产生冲突。

### 2.1	类的导入

​	一个类可以使用所属包中的所有类， 以及其他包中的公有类（public class)。

​	有两种方式访问另一个包中的公有类:

​		① 第一种方式是在每个类名之前添加完整的包名:

```java
java.time.LocalDate today = java.time.LocalDate.now();
```

​		② 第二种方式是使用import语句。可以使用import语句导入一个特定的类或者整个包，这样就不用写出包的全名了:

```java
import java.time.LocalDate;//导入特定的类
import java.util.*;//导入整个包。注意*在一个import语句内只能使用一次
```

### 2.2	静态导入

​	import 语句不仅可以导人类，还增加了导入静态方法和静态域的功能。例如，如果在源文件的顶部， 添加一条指令：

```java
import static java.lang.System.*;
```

​	就可以使用 System 类的静态方法和静态域，而不必加类名前缀:

```java
out.println("Goodbye, World!"); // System.out
exit(0); //System.exit
```

​	另外，还可以导入特定的方法或域：

```java
import static java.lang.System.out;
```

### 2.3	包作用域

​	修饰符**public**和**private**对**类、方法、变量**的作用:

​		① 被标记为 **public** : 可以被任意的类使用。

​		② 被标记为 **private**: 只能被定义它们的类使用。

​		③ 既没有被 **public** 也没有 **private** 标记: 可以被同一个包中的所有方法访问。

### 2.4	类路径

​	好复杂，先跳过。



## 3.0	文档注释（注解?）

​	重要但不紧急，日后必看。





## 4.0	类设计要点

​	为了更具OOP的专业水准:

​		① **一定要保证数据私有**

​		绝对不要破坏封装性性。有时候， 需要编写一个访问器方法或更改器方法，但是最好还是保持实例域的私有性。数据的表示形式很可能会改变， 但它们的使用方式却不会经常发生变化。当数据保持私有时， 它们的表示形式的变化不会对类的使用者产生影响， 即使出现 bug 也易于检测。

​		② **一定要对数据初始化**

​		最好不要依赖系统的默认值，而是应该显式地初始化所有的数据。

​		③ **不要在类中使用过多的基本类型**

​		用库类或自定义的类代替多个相关的基本类型的使用。这样会使类更加易于理解且易于修改。

​		④ **不是所有的域都需要独立的域访问器和域更改器**

​		⑤ **将职责过多的类进行分解**

​		⑥ **类名和方法名要能够体现它们的职责功能**

​		命名类名的良好习惯是采用一个名词(**Order** )、 前面有形容词修饰的名词(**RushOrder** )或动名词（有“ -**ing**” 后缀）修饰名词（例如,**BillingAddress**)。对于方法来说，习惯是访问器方法用小写**get**开头 (**getSalary** ), 更改器方法用小写的 **set** 开头（**setSalary** )。

​		⑦ **优先使用不可变的类**

​		**LocalDate** 类以及 **java**.**time** 包中的其他类是不可变的没有方法能修改对象的状态。类似 **plusDays** 的方法并不是更改对象，而是返回状态已修改的新对象。其结果是不可预料的。如果类是不可变的，就可以安全地在多个线程间共享其对象。

​		当然，并不是所有类都应当是不可变的。如果员工加薪时让 **raiseSalary** 方法返回一个新的 **Employee** 对象， 这会很奇怪。

## 5.0 API与API文档

​	API(Application Programming Interface): 应用程序编程接口

​	Java API: 指的就是JDK中提供的各种功能的Java类

​	这些类将底层的实现封装了起来，使得我们不需要关心这些类是如何实现的，只需要学习这些类是如何使用的即可。这极大地减少了学习和使用Java开发的成本。

​	API帮助文档: 帮助开发人员更好的使用API和查询API的一个工具。里面有Java已经定义好的各种包的(及其中的类和方法)简要介绍和签名。



## 6.0	浅拷贝和深拷贝

​	深拷贝是复制对象的时候，对象下面的字段如果是类类型的话也要复制，递归的向下复制，浅拷贝是复制一个对象，对象下面的字段如果是基础类型就值复制，如果是类类型就只复制引用。

​	使用clone()方法需要先实现Cloneable

[^1]: 方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成。注意!方法签名不包括方法的返回类型、返回值、和访问修饰符。

