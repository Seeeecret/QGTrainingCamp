# 数据结构

## 1.0	二叉树 及其变种

​	**树(Tree)**, 本身就是一种数据结构, 二叉树是其中一种。**树高**描述一棵**树**的总层数。

​	**节点(Node)**: 树中的每个节点都存储着其父节点的地址值、左子节点的地址值、右子节点的地址值，以及其本身要存储的数据值。**左子节点**与**右子节点**分别表示某节点左下方和右下方的节点，此外还有类似概念的**左子树**和**右子树**。**根节点**为一棵树最顶层的节点

​	**度**: 用来描述一棵树中节点的子节点数量。而在二叉树中，任意节点的度<=2。

​	**平衡因子**: 该节点左子树的高度-该节点右子树的高度=~

​	普通的二叉树存放数据的顺序没有什么规律可言，重点是其变种们:

## 1.1	二叉查找树

​	**二叉查找树**在对节点的增加方面遵循以下规则: 小的存左边，大的存右边，一样的不存。

### 1.11	遍历方式

- 前序遍历: 从根节点开始，然后按照<u>当前节点，左子节点，右子节点的顺序遍历</u>。
- 中序遍历: 从最左侧的子节点开始，然后按照<u>左子节点，当前结点，右子节点的顺序遍历</u>。(此遍历方式最为重要, 因为遍历的顺序为**从小到大**)
- 后序遍历: 从最左边的子节点开始, 然后按照<u>左子节点，右子节点，当前结点的遍历顺序</u>。
- 层序遍历: 从根节点开始一层一层的遍历，即广度优先搜索(BFS)。

###  1.12	弊端

​	若插入节点的顺序接近升序或逆序，则生成的二叉查找树树高会非常大，查找效率较低，会**退化**为单向链表。下面这种二叉树会解决这个问题:

## 1.2	平衡二叉树(AVL)

​	在二叉查找树的规则上，附上<u>任意节点左右子树的高度差不超过1</u>的限制。

### 1.21	旋转

​	当添加某节点后,<u>任意节点左右子树的高度差不超过1</u>的限制被打破了，则称此平衡二叉树不再**平衡**。为了恢复平衡，则需要将平衡二叉树**旋转**。

#### 1.211	左旋

​	当平衡从右子树被破坏时，其中一种进行旋转恢复平衡的操作如下:

1. 从添加的节点开始，不断的往父节点找不平衡的节点，确定旋转的**支点**。
1. 将支点往左下方拉左旋降级，成为左子节点
1. 晋升原来支点的右子节点，成为支点的父节点。

​	**特殊情况**: 

- 如果支点和支点的右子节点都没有**挂载左子节点**，那么皆大欢喜。
- 如果支点的右子节点挂载了左子节点，那么其在晋升时与左子节点的连接就要断开，连到降级的支点上，成为支点的右子节点(设计根节点的情况也是如此)
- 如果支点挂载了左子节点操作分别同上。



#### 1.212	右旋

​	当平衡从左子树被破坏时，其中一种进行旋转恢复平衡的操作如下:

 1. 从添加的节点开始，不断的往父节点找不平衡的节点，确定旋转的**支点**。
 2. 将支点往右下方拉右旋降级，成为右子节点
 3. 晋升原来支点的左子节点，成为支点的父节点。

​	**特殊情况**: 

- 如果支点和支点的左子节点都没有挂载右子节点，那么皆大欢喜。
- 如果支点的左子节点挂载了右子节点，那么其在晋升时与左子节点的连接就要断开，连到降级的支点上，成为支点的左子节点(设计根节点的情况也是如此)
- 如果支点挂载了右子节点操作分别同上。



#### 1.215	需要旋转的四种情况

1. 左左: 根节点的左子树 的 左子树有节点插入，导致二叉树不平衡

​	处理方案: 一次右旋即可

2. 左右:根节点的左子树 的 右子树有节点插入，导致二叉树不平衡

​	处理方案: 对根节点的左子树进行一次左旋，变成左左。之后再右旋即可。

3. 右右:根节点的右子树 的 右子树有节点插入，导致二叉树不平衡

​	处理方案: 一次左旋即可

4. 右左:根节点的右子树 的 左子树有节点插入，导致二叉树不平衡

​	解决方案:对根节点的右子树进行一次右旋，变成右右。之后再左旋即可。

### 1.23	弊端

​	节点数量大时，因为插入节点平衡破坏导致需要进行多次旋转的时间开销不容忽视。

## 1.3	红黑树

​	**红黑树**是一种自平衡的二叉查找树，但不是高度平衡的，即不是平衡二叉树。红黑树的平衡是通过特有的"红黑规则"实现的。它的每一个节点都要对应的存储位表示节点的颜色，每个节点都可以是红或者是黑。添加节点是默认颜色为红色，因为调整次数更少，效率更高。红黑树的增删改查性能都很好。

​	**叶节点**: 没有子节点的节点

​	**后代**: 由某节点衍生出的所有子节点

​	**简单路径**: 只向下，不返回的路径。

### 1.31	红黑规则

1. 每一个节点或是红色的，或者是黑色的根节点必须是黑色
2. 根节点必须是黑色;
3. 如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为**叶节点**，每个叶节点(Nil)是黑色的
4. 如果某一个节点是红色，那么它的子节点必须是黑色(<u>不能出现两个红色节点相连的情况</u>)
5. 对每一个节点，从该节点到其所有后代叶节点的**简单路径**上，均<u>包含相同数目的黑色节点</u>;

### 1.32	添加规则

​	黑马视频截图总结:

### ![tree](https://mytyporapicute.oss-cn-guangzhou.aliyuncs.com/tree.png)



​	